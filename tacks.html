<!DOCTYPE html>
<html lang="en-UK">
<head>
	<meta charset="utf-8"/>
	<title>Tacks</title>
	<meta name="viewport" content="width=device-width"/>
<style>
:root{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #f5f1ec;
	--feature: coral;
}
.light{
	--black: #171717;
	--white: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #5c5b59;
	--feature: coral;
}
.dark{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #f5f1ec;
	--feature: coral;
}
body{
	width: 100%;
	text-align: center;
	align-content: center;
	background-color: var(--white);
	color: var(--black);
	font-family:monospace;
	margin: 0px;
	overflow: hidden;
}
.dark-mode{
	background-color: var(--black);
	color: var(--white);
}
h1 {
	text-align: center;
	color: var(--black);
}
h1.title{
	text-align: center;
	color:  vaR(--black);
	font-size: 48px;
	margin: 0px;
}
h2 {
	font-size: 24px;
	margin: 8px;
	color: var(--black);
}
button{
	font-size: 16px;
	padding: 8px;
	margin: 4px;
	color: var(--white);
	background-color: var(--black);
	transition-duration: 0.2s;
	font-family: monospace;
	font-weight: bold;
}
button:hover{
	background-color: var(--feature);

}
label{
	font-size: 32px;
	color: var(--black);
	padding: 12px;
	font-family: monospace;
}
label.small{
	font-size: 16px;
	padding: 2px;
}
footer {
	position: fixed;
	left: 0;
	bottom: 0;
	width: 100%;
	text-align: center;
	align-content: center;
}
div.widget{
	background-color: var(--white);
	border: solid 1px var(--black);
	min-width: 250px;
	width: fit-content;
	padding: 12px;
	margin: 12px;
	border-radius: 4px;
	text-align: center;
}
#ascii{
	max-width: 100vw;
	min-width: 100vw;
	overflow-x: hidden;
	position: absolute;
	top: -20px;
	left: 0;
	color: var(--ascii);
}
.notification{
	color: var(--white);
	padding: 10px;
	font-family: monospace;
	transition-duration: 0.2s;
	z-index: -1;
	width: fit-content;
}
.notification.show{
	opacity: 0.9;
}
.notification.hide{
	opacity: 0;
}
.slice{
	width: 100vw;
	height: fit-content;
	padding: 12px;
	align-items: center;
	align-content: center;
	display: flex;
	flex-direction: column;
}
canvas{
	height: 200px;
	width: 100vw;
}
</style>
</head>
<! ========================================================================= >
<body>
	<pre id="ascii" style="z-index: -1;"></pre>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
		<div style="background-color: var(--white); z-index: 2; display: flex; flex-direction: column; align-items: center; border: solid 1px var(--black);
					width: fit-content; padding-left: 80px; padding-right: 80px; padding-top: 16px; padding-bottom: 16px;; margin-top: 64px; align-content: center;">
			<h1 class="title">Tacks</h1>
			<p style="color: var(--black); margin-top: 0px;">A Lesser Paperclips</p>
		</div>
		
	</div>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%; margin-top: 72px">
		<div class="widget">
			<p style="text-align:center" id="tpsLbl">Click to increment.</p>

			<label id="tacksLbl">0</label>
			<br>
			<button id="btn">Boop</button>
		</div>
	</div>
	<h2> Upgrades & Automation</h2>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%; gap: 0px;">
		<div style="width: fit-content">
			<div id="pointerSlice" class="slice">
				<canvas id="pointerCanvas" style="height: 200px; width: 100vw"></canvas>
				<div class="widget" style="margin-top: -160px;">
					<button id="pointerBtn">Buy Extra pointer</button>
					<div>
						<label class="small">+0.25 per click</label> <br>
						<label class="small">Cost: 20</label>
						<br>
						<label class="small">Owned:<label class="small" id="pointerAmountLbl">0</label></label>
					</div>
				</div>
			</div>
			<div style="width: 100% - 64px; height: 1px; margin-top: 16px; background-color: var(--ascii); margin-left: 32px; margin-right: 32px;"></div>
			<div id="workerSlice" class="slice">
				<canvas id="workerCanvas" style="height: 200px; width: 100vw"></canvas>
				<div class="widget" style="margin-top: -160px">
					<button id="workerBtn">Buy Worker</button>
					<div>
						<label class="small">+0.4 per second</label><br>
						<label class="small">Cost: 100</label>
						<br>
						<label class="small">Owned:<label class="small" id="workerAmountLbl">0</label></label>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div style="position: absolute; right: 20px; bottom: 80px; text-align: right;">
		<label class="small"; id="dateTimeLbl">DateTime</label>
		<br>
		<label class="small"; id="upTimeLbl">UpTime</label>
		<br>
		<label class="small"; id="playedTimeLbl">PlayedTime</label>
		<br>
		<p>Add more debug stuff.</p>
	</div>
	<div style="position:absolute; bottom: 40px; left: 80px;">
		<h2>Preferences</h2>
		<button id="toggleDark">Toggle Theme</button><br>
		<button id="saveGame">Save</button>
		<button id="newGame">New</button>
	</div>
	<div id="notificationContainer" style="position: absolute; z-index: -1; display: flex; bottom: 80px; text-align: center; align-items: center; width: 99%; flex-direction: column-reverse;">
	</div>
<footer>
	Â© Ryan Appleyard MMXXV
</footer>


</body>

<! ========================================================================= >

<script>

// #region Data

const DATA = {
	tacks: 0,
	pointerAmount: 0,
	workerAmount: 0,
	playedTime: 0
}

// Light and Dark refer to the themes they are paired with.
const COLOURS = {
	green: {
		light: "#3C983E",
		dark: "#6FD08C"
	},
	red: "#FC5130",
	text: {
		light: "#111111",
		dark: "#FFFFFF"
	},
	ascii: {
		light: "#5c5b59",
		dark: "#f5f1ec"
	}
}
let AutoValue = {
	pointer: 0.25,
	WORKER: 0.4
};

let AutoPrice = {
	pointer: 20,
	WORKER: 100
}

const saveData = {
	version: "1.0.0",
	resources: {
		tacks: DATA.tacks,
		pointerAmount: DATA.pointerAmount,
		workerAmount: DATA.workerAmount,
		playedTime: DATA.playedTime
	},
	//add whatever else.
	lastSave: Date.now()
}

// #endregion

let TPS = 0;
const FPS = 1000 / 32;
const tpsLbl = document.getElementById("tpsLbl");

let upTime = 0;
let startTime = Date.now();

// const upTimeLbl = document.getElementById("upTimeLbl");
// const dateTimeLbl = document.getElementById("dateTimeLbl");
// const playedTimeLbl = document.getElementById("playedTimeLbl");
const notificationContainer = document.getElementById("notificationContainer");

const updateLabel = {
	tacks: (val) => { document.getElementById("tacksLbl").textContent = val; },
	pointerAmount: (val) => { document.getElementById("pointerAmountLbl").textContent = val; },
	workerAmount: (val) => { document.getElementById("workerAmountLbl").textContent = val; },
	// Add more as needed...
};

// #region Save Logic

function newGame() {
	// Clear the saved data
	localStorage.removeItem("tacksSave");
	loadGame();
	refresh();

	// Optional: notify the player
	printNotification("New Game Started", COLOURS.green);
}



const FIXED_KEY = "tackstack-key123"; // Shared secret
const FIXED_SALT = new TextEncoder().encode("tackstack-salt");

// Derive a persistent key using PBKDF2
async function getKey() {
	if (!window.encryptionKey) {
		const keyMaterial = await crypto.subtle.importKey(
			"raw",
			new TextEncoder().encode(FIXED_KEY),
			{ name: "PBKDF2" },
			false,
			["deriveKey"]
		);

		window.encryptionKey = await crypto.subtle.deriveKey(
			{
				name: "PBKDF2",
				salt: FIXED_SALT,
				iterations: 100000,
				hash: "SHA-256"
			},
			keyMaterial,
			{ name: "AES-GCM", length: 256 },
			false,
			["encrypt", "decrypt"]
		);
	}
	return window.encryptionKey;
}

async function saveGame(autosave) {
	const key = await getKey();
	const iv = crypto.getRandomValues(new Uint8Array(12));
	const encoded = new TextEncoder().encode(JSON.stringify(DATA));
	const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

	const encryptedData = {
		iv: Array.from(iv),
		cipherText: Array.from(new Uint8Array(encrypted))
	};

	localStorage.setItem("tacksSave", JSON.stringify(encryptedData));

	if (!autosave) printNotification("Saved Game", COLOURS.green);
}

function autosaveGame() {
	saveGame(true);
	printNotification("Autosaved", COLOURS.green, 2000);
}

async function loadGame() {
	const raw = localStorage.getItem("tacksSave");
	if (!raw) return;

	try {
		const encryptedData = JSON.parse(raw);
		const key = await getKey();
		const iv = new Uint8Array(encryptedData.iv);
		const cipherText = new Uint8Array(encryptedData.cipherText);

		const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherText);
		const json = new TextDecoder().decode(decrypted);
		const parsed = JSON.parse(json);

		DATA.tacks = parsed.tacks || 0;
		DATA.pointerAmount = parsed.pointerAmount || 0;
		DATA.workerAmount = parsed.workerAmount || 0;
		DATA.playedTime = parsed.playedTime || 0;

		refresh();
		printNotification("Game Loaded", COLOURS.green);
	} catch (err) {
		console.error("Decryption failed:", err);
	}
}


// #endregion


loadGame();
automation();

// #region Game Logic

document.getElementById("btn").addEventListener("click", context=>{
	increment((DATA.pointerAmount * AutoValue.pointer) + 1);
});

document.getElementById("pointerBtn").addEventListener("click", context=>{
	if(canAfford(AutoPrice.pointer)){
		buy("pointer", 1, AutoPrice.pointer);
		createPointer();
	}
});

document.getElementById("workerBtn").addEventListener("click", context=>{
	if(canAfford(AutoPrice.WORKER)){
		buy("worker", 1, AutoPrice.WORKER);
		createGuy();
	}
});

document.getElementById("toggleDark").addEventListener("click", function(){
	var element = document.body;
	element.classList.toggle("light");
});

document.getElementById("saveGame").addEventListener("click", function(){
	saveGame();
})

document.getElementById("newGame").addEventListener("click", function(){
	newGame();
})

setInterval(automation, 1000);
setInterval(display, FPS);
setInterval(autosaveGame, 600000);

function refresh(){
	setDataField("tacks", DATA.tacks);
	setDataField("workerAmount", DATA.workerAmount);
	setDataField("pointerAmount", DATA.pointerAmount);
	populateGuys(DATA.workerAmount);
	populatePointers(DATA.pointerAmount);
	// Calculate compounding price changes.
}

function increment(amount){
	DATA.tacks += amount;
}

function incrementSpecific(name, amount) {
	const label = document.getElementById(name + "Lbl");

	if (!label) {
		console.warn(`Label element not found: ${name}Lbl`);
		return;
	}

	let currentVal = parseFloat(label.textContent);
	if (isNaN(currentVal)) currentVal = 0;

	const newVal = currentVal + amount;
	label.textContent = Math.floor(newVal);
}


function incrementDataField(fieldName, amount = 1) {
	if (Object.prototype.hasOwnProperty.call(DATA, fieldName) && typeof DATA[fieldName] === "number") {
		DATA[fieldName] += amount;

		// Check for a label updater function specific to this field
		if (typeof updateLabel[fieldName] === "function") {
			updateLabel[fieldName](DATA[fieldName]);
		}

		return DATA[fieldName];
	} else {
		console.warn(`Invalid field name or non-numeric field: "${fieldName}"`);
		return null;
	}
}

function setDataField(fieldName, amount = 1) {
	if (Object.prototype.hasOwnProperty.call(DATA, fieldName) && typeof DATA[fieldName] === "number") {
		DATA[fieldName] = amount;

		// Check for a label updater function specific to this field
		if (typeof updateLabel[fieldName] === "function") {
			updateLabel[fieldName](DATA[fieldName]);
		}

		return DATA[fieldName];
	} else {
		console.warn(`Invalid field name or non-numeric field: "${fieldName}"`);
		return null;
	}
}


function decrement(amount){
	DATA.tacks -= amount;
}

function canAfford(price){
	return true ? price <= parseInt(DATA.tacks, 10) : false;
}

function buy(type, amount, price){
	if(canAfford(price)){
		decrement(price);
		incrementDataField(type + "Amount", amount);
		printNotification("Bought: " + amount + "x " + type, COLOURS.text, 2000);
		return true;
	}
	else{
		printNotification("Can't afford another " + type, COLOURS.red, 2000);
		return false;
	}		
}

// Called once per second
function automation(){
	calculateTPS();
	tpsLbl.textContent = "Tacks p/s: " + TPS.toFixed(2);
	dateTimeLbl.textContent = new Date().toLocaleString();
	upTime++;
	var upTimeElapsed = convertTime(upTime);
	upTimeLbl.textContent = "Up Time: " + upTimeElapsed;
	DATA.playedTime++;
	var playedTimeElapsed = convertTime(DATA.playedTime)
	playedTimeLbl.textContent = "Played Time: " + playedTimeElapsed;
}

// Called 24 times per second
function display(){
	increment(TPS / FPS);
	tacksLbl.textContent = numberWithCommas(Math.floor(DATA.tacks));
}

function calculateTPS(){
	TPS = AutoValue.WORKER * DATA.workerAmount;
}
// #endregion

// #region Print & Display

function convertTime(timeIn){
	const hours = Math.floor(timeIn / 3600);
	const minutes = Math.floor((timeIn % 36000) / 60);
	const seconds = timeIn % 60;

	return hours + "h " + minutes + "m " + seconds + "s";
}

function printNotification(message, color, duration = 3000){
	const note = document.createElement("div");
	note.className = "notification";
	note.textContent = message;
	note.style.color = getColor(color);

	notificationContainer.appendChild(note);

	setTimeout(() =>{
		note.classList.remove("show");
		note.classList.add("hide");
		setTimeout(() => note.remove(), 500);
	}, duration);
}

function getColor(type) {
    if (typeof type === "string") return type;
    return isLightMode() ? type.light : type.dark;
}

function isLightMode() {
    return document.body.classList.contains("light");
}

function numberWithCommas(x) {
    x = x.toString();
    var pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(x))
        x = x.replace(pattern, "$1,$2");
    return x;
}

window.addEventListener("resize", resizeCanvas);
function resizeCanvas(){
	workerCanvas.width = window.innerWidth - 80;
	pointerCanvas.width = window.innerWidth - 80;

	workers.forEach(g =>{
		g.homeX = Math.random() * workerCanvas.width;
	})

	pointers.forEach(p =>{
		p.homeX = Math.random() * pointerCanvas.width;
	})
}

// #endregion

// #region Perlin
const perm = new Uint8Array(512);
for (let i = 0; i < 256; i++) perm[i] = i;
for (let i = 255; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [perm[i], perm[j]] = [perm[j], perm[i]];
}
for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];

function fade(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return a + t * (b - a);
}

function grad(hash, x, y, z) {
  const h = hash & 15;
  const u = h < 8 ? x : y;
  const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
  return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

function perlin(x, y, z) {
  const X = Math.floor(x) & 255;
  const Y = Math.floor(y) & 255;
  const Z = Math.floor(z) & 255;

  x -= Math.floor(x);
  y -= Math.floor(y);
  z -= Math.floor(z);

  const u = fade(x);
  const v = fade(y);
  const w = fade(z);

  const A  = perm[X] + Y, AA = perm[A] + Z, AB = perm[A + 1] + Z;
  const B  = perm[X + 1] + Y, BA = perm[B] + Z, BB = perm[B + 1] + Z;

  return lerp(
    lerp(
      lerp(grad(perm[AA], x, y, z),
           grad(perm[BA], x - 1, y, z), u),
      lerp(grad(perm[AB], x, y - 1, z),
           grad(perm[BB], x - 1, y - 1, z), u), v),
    lerp(
      lerp(grad(perm[AA + 1], x, y, z - 1),
           grad(perm[BA + 1], x - 1, y, z - 1), u),
      lerp(grad(perm[AB + 1], x, y - 1, z - 1),
           grad(perm[BB + 1], x - 1, y - 1, z - 1), u), v),
    w
  );
}

// const chars = " '   .,-*=##$&@";
const chars = "    ..:oO0@ ";
const userScreen = document.getElementById("ascii");
let t = 0;
let paused = false;

function mapValueToChar(val) {
  const normalized = (val + 1) / 2;
  const index = Math.floor(normalized * (chars.length - 1));
  return chars[index];
}

function renderFrame() {
    if (!paused) {
        let output = "";
        const width = userScreen.clientWidth / 6;

		if(width == 0) console.log("ISSUE");
        const height = 18;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const value = perlin(x * 0.1, y * 0.1, t);
        output += mapValueToChar(value);
      }
      output += "\n";
    }

    userScreen.textContent = output;
    t += 0.01;
  }
}

// Don't want this for prod
// document.addEventListener("keydown", (e) => {
//   if (e.code === "Space") paused = !paused;
// });

setInterval(renderFrame, FPS);

// #endregion


// This is where the work is. Refactor to make it more modular, and add in the hand logic.
// Use sin wave function to get a poking effect.

// Also improvements to the guys, including variants.

// #region Ascii Shared

const WIGGLE_AMPLITUDE = 2; // max wiggle in pixels
const WIGGLE_SPEED = 0.01;  // speed of wiggle
const REPULSION_RADIUS = 450; // smaller radius so repulsion looks nicer
const REPULSION_FORCE = 2; // how strongly guys get pushed away

const BASE_FONT_SIZE = 12;
const MAX_FONT_SIZE = 16;
const SCALE_RADIUS = 100;


// #endregion

// #region Guys

const workerCanvas = document.getElementById("workerCanvas");
const workerCtx = workerCanvas.getContext("2d");
workerCanvas.width = window.innerWidth;
workerCanvas.height = 200;

const CHAR_GUY = [
[
	"  o  ",
	" /#\\ ",
	" / \\ "
],
[
	"  o  ",
	" <#v ",
	" / \\ "
],
[
	"  o  ",
	" <T> ",
	" / \\ "
],
[
	"  o  ",
	" /#> ",
	" / \\ "
],
[
	"  o  ",
	" /X\\ ",
	" / \\ "
]];

let workerCount;
const workerMouse = { x: 0, y: 0 };
const workers = [];

function populateGuys(guysCount){
	// Initialize guys with fixed home positions and unique IDs
	for (let i = 0; i < guysCount; i++) {
		workers.push({
			homeX: Math.random() * (workerCanvas.width - 80),
			homeY: Math.random() * (workerCanvas.height - 20),
			id: i,
			sprite: CHAR_GUY[Math.floor(Math.random() * CHAR_GUY.length)]
		});
	}
}

workerCanvas.addEventListener("mousemove", e => {
	const rect = workerCanvas.getBoundingClientRect(); // get canvas position & size
	workerMouse.x = e.clientX - rect.left; // mouse x relative to canvas
	workerMouse.y = e.clientY - rect.top;  // mouse y relative to canvas
});

// canvas.addEventListener("click", () => {
//   guysCount++;
//   guys.push({
//     homeX: mouse.x,
//     homeY: mouse.y,
//     id: guysCount
//   });
//   console.log(`Added guy #${guysCount} at (${mouse.x}, ${mouse.y})`);
// });

function createGuy(){
	workerCount++;
	workers.push({
		homeX: Math.random() * (workerCanvas.width - 80),
		homeY: Math.random() * (workerCanvas.height - 20),
		id: workerCount,
		sprite: CHAR_GUY[Math.floor(Math.random() * CHAR_GUY.length)]
	});
}

function drawGuy(guySprite, x, y, scale) {
	const fontSize = BASE_FONT_SIZE * scale;
	const lineHeight = fontSize;

	workerCtx.font = fontSize + "px monospace";
	workerCtx.textBaseline = "top";
	workerCtx.fillStyle = getColor(COLOURS.ascii);
	for (let i = 0; i < guySprite.length; i++) {
		workerCtx.fillText(guySprite[i], x, y + i * lineHeight);
	}
}

let time = 0;

function updateWorker() {
	workerCtx.clearRect(0, 0, workerCanvas.width, workerCanvas.height);
	time += WIGGLE_SPEED;


	workers.forEach(g => {
		// Calculate distance to mouse
		const dx = g.homeX - workerMouse.x;
		const dy = g.homeY - workerMouse.y;
		const dist = Math.sqrt(dx * dx + dy * dy);

		// Perlin noise wiggle
		const noiseX = perlin(time + g.id * 10, 0, 0) * 2 - 1; // [-1, 1]
		const noiseY = perlin(0, time + g.id * 10, 0) * 2 - 1;
		const wiggleX = noiseX * WIGGLE_AMPLITUDE;
		const wiggleY = noiseY * WIGGLE_AMPLITUDE;

		let offsetX = wiggleX;
		let offsetY = wiggleY;

		// If within repulsion radius, push away from mouse
		if (dist < REPULSION_RADIUS && dist > 0.01) {
		const nx = dx / dist;
		const ny = dy / dist;
		const repulseStrength = (REPULSION_RADIUS - dist) / REPULSION_RADIUS * REPULSION_FORCE;
		offsetX += nx * repulseStrength;
		offsetY += ny * repulseStrength;
		}

		let scale = 1;
		if(dist < SCALE_RADIUS){
			const t= 1 - dist / SCALE_RADIUS;
			scale = 1 + t * ((MAX_FONT_SIZE / BASE_FONT_SIZE) -1);
		}

		const drawX = g.homeX + offsetX;
		const drawY = g.homeY + offsetY;

		drawGuy(g.sprite, drawX, drawY, scale);
	});

	requestAnimationFrame(updateWorker);
}

// #endregion

// #region Pointers

const pointerCanvas = document.getElementById("pointerCanvas");
const ctx2 = pointerCanvas.getContext("2d");
pointerCanvas.width = window.innerWidth;
pointerCanvas.height = 200;

const CHAR_POINTER = [[
	"   |  ",
	"r^^|  ",
	"\\__|) "
]];

let pointerCount;
const pointerMouse = { x: 0, y: 0 }
const pointers = [];


function populatePointers(pointerCount){
	for (let i = 0; i < pointerCount; i++) {
		pointers.push({
			homeX: Math.random() * (pointerCanvas.width - 80),
			homeY: Math.random() * (pointerCanvas.height - 20),
			id: i,
			sprite: CHAR_POINTER[Math.floor(Math.random() * CHAR_POINTER.length)]
		});
	}
}

// pointerCanvas.addEventListener("click", () => {
//     pointerCount++;
//     pointers.push({
//         homeX: pointerMouse.x,
//         homeY: pointerMouse.y,
//         id: pointerCount,
//         sprite: CHAR_POINTER[Math.floor(Math.random() * CHAR_POINTER.length)]
//     });
//     console.log(`Added pointer #${pointerCount} at (${pointerMouse.x}, ${pointerMouse.y})`);
// });

pointerCanvas.addEventListener("mousemove", e => {
    const rect = pointerCanvas.getBoundingClientRect(); // get canvas position & size
    pointerMouse.x = e.clientX - rect.left; // mouse x relative to canvas
    pointerMouse.y = e.clientY - rect.top;  // mouse y relative to canvas
});

function createPointer(){
	pointerCount++;
	pointers.push({
		homeX: Math.random() * (pointerCanvas.width - 80),
		homeY: Math.random() * (pointerCanvas.height - 20),
		id: pointerCount,
		sprite: CHAR_POINTER[Math.floor(Math.random() * CHAR_POINTER.length)]
	});
}

function drawPointer(pointerSprite, x, y, scale) {
    const fontSize = BASE_FONT_SIZE * scale;
    const lineHeight = fontSize;

    ctx2.font = fontSize + "px monospace";
    ctx2.textBaseline = "top";
    ctx2.fillStyle = getColor(COLOURS.ascii);

    for (let i = 0; i < pointerSprite.length; i++) {
        ctx2.fillText(pointerSprite[i], x, y + i * lineHeight);
    }
}

function updatePointer() {
    ctx2.clearRect(0, 0, pointerCanvas.width, pointerCanvas.height);
    time += WIGGLE_SPEED;

    pointers.forEach(p => {
        // Calculate distance to mouse
        const dx = p.homeX - pointerMouse.x;
        const dy = p.homeY - pointerMouse.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Perlin noise wiggle
        const noiseX = perlin(time + p.id * 10, 0, 0) * 2 - 1; // [-1, 1]
        const noiseY = perlin(0, time + p.id * 10, 0) * 2 - 1;
        const wiggleX = noiseX * WIGGLE_AMPLITUDE;
        const wiggleY = noiseY * WIGGLE_AMPLITUDE;

        let offsetX = wiggleX;
        let offsetY = wiggleY;

        // If within repulsion radius, push away from mouse
        if (dist < REPULSION_RADIUS && dist > 0.01) {
        const nx = dx / dist;
        const ny = dy / dist;
        const repulseStrength = (REPULSION_RADIUS - dist) / REPULSION_RADIUS * REPULSION_FORCE;
        offsetX += nx * repulseStrength;
        offsetY += ny * repulseStrength;
        }

        let scale = 1;
        if(dist < SCALE_RADIUS){
            const t= 1 - dist / SCALE_RADIUS;
            scale = 1 + t * ((MAX_FONT_SIZE / BASE_FONT_SIZE) -1);
        }

        const drawX = p.homeX + offsetX;
        const drawY = p.homeY + offsetY;

        drawPointer(p.sprite, drawX, drawY, scale);
    });
    
    requestAnimationFrame(updatePointer);
}

// #endregion


updatePointer();
updateWorker();

</script>
</html>
























