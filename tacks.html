<!DOCTYPE html>
<html lang="en-UK">
<head>
	<meta charset="utf-8"/>
	<title>Tacks</title>
	<meta name="viewport" content="width=device-width"/>
<style>
:root{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #f5f1ec;
	--feature: coral;
}
.light{
	--black: #171717;
	--white: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #5c5b59;
	--feature: coral;
}
.dark{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #f5f1ec;
	--feature: coral;
}
body{
	width: 100%;
	text-align: center;
	align-content: center;
	background-color: var(--white);
	color: var(--black);
	font-family:monospace;
	margin: 0px;
	overflow: hidden;
}
.dark-mode{
	background-color: var(--black);
	color: var(--white);
}
h1 {
	text-align: center;
	color: var(--black);
}
h1.title{
	text-align: center;
	color:  vaR(--black);
	font-size: 48px;
	margin: 0px;
}
h2 {
	font-size: 24px;
	margin: 8px;
	color: var(--black);
}
button{
	font-size: 16px;
	padding: 8px;
	margin: 4px;
	color: var(--white);
	background-color: var(--black);
	transition-duration: 0.2s;
	font-family: monospace;
	font-weight: bold;
}
button:hover{
	background-color: var(--feature);

}
label{
	font-size: 32px;
	color: var(--black);
	padding: 12px;
	font-family: monospace;
}
label.small{
	font-size: 16px;
	padding: 2px;
}
footer {
	position: fixed;
	left: 0;
	bottom: 0;
	width: 100%;
	text-align: center;
	align-content: center;
}
div.widget{
	background-color: var(--white);
	border: solid 1px var(--black);
	min-width: 250px;
	width: fit-content;
	padding: 12px;
	margin: 12px;
	border-radius: 4px;
	text-align: center;
}
#ascii{
	max-width: 100vw;
	min-width: 100vw;
	overflow-x: hidden;
	position: absolute;
	top: -20px;
	left: 0;
	color: var(--ascii);
}
.notification{
	color: var(--white);
	padding: 10px;
	font-family: monospace;
	transition-duration: 0.2s;
	z-index: -1;
	width: fit-content;
}
.notification.show{
	opacity: 0.9;
}
.notification.hide{
	opacity: 0;
}
.slice{
	width: 100vw;
	height: fit-content;
	padding: 12px;
	align-items: center;
	align-content: center;
	display: flex;
	flex-direction: column;
}
canvas{
	height: 200px;
	width: 100vw;
}
</style>
</head>
<! ========================================================================= >
<body>
	<pre id="ascii" style="z-index: -1;"></pre>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%;">
		<div style="background-color: var(--white); z-index: 2; display: flex; flex-direction: column; align-items: center; border: solid 1px var(--black);
					width: fit-content; padding-left: 80px; padding-right: 80px; padding-top: 16px; padding-bottom: 16px;; margin-top: 64px; align-content: center;">
			<h1 class="title">Tacks</h1>
			<p style="color: var(--black); margin-top: 0px;">A Lesser Paperclips</p>
		</div>
		
	</div>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%; margin-top: 72px">
		<div class="widget">
			<p style="text-align:center" id="tpsLbl">Click to increment.</p>

			<label id="lbl">0</label>
			<br>
			<button id="btn">Boop</button>
		</div>
	</div>
	<h2> Upgrades & Automation</h2>
	<div style="display: flex; flex-direction: column; align-items: center; width: 100%; gap: 0px;">
		<div style="width: fit-content">
			<div id="fingerSlice" class="slice" style="height: 200px; background-color: blue;">
				<canvas id="fingerCanvas" style="height: 200px; width: 100vw"></canvas>
				<div class="widget" style="margin-top: -160px;">
					<button id="fingerBtn">Buy Extra Finger</button>
					<div>
						<label class="small">+0.25 per click</label> <br>
						<label class="small">Cost: 20</label>
						<br>
						<label class="small">Owned:<label class="small" id="fingerLbl">0</label></label>
					</div>
				</div>
			</div>
			<div id="workerSlice" class="slice">
				<canvas id="workerCanvas"></canvas>
				<div class="widget" style="margin-top: -160px">
					<button id="workerBtn">Buy Worker</button>
					<div>
						<label class="small">+0.4 per second</label><br>
						<label class="small">Cost: 100</label>
						<br>
						<label class="small">Owned:<label class="small" id="workerLbl">0</label></label>
					</div>
				</div>
			</div>
		</div>
	</div>
	<div style="position: absolute; right: 20px; bottom: 80px; text-align: right;">
		<label class="small"; id="dateTimeLbl">DateTime</label>
		<br>
		<label class="small"; id="upTimeLbl">UpTime</label>
		<br>
		<label class="small"; id="playedTimeLbl">PlayedTime</label>
		<br>
		<p>Add more debug stuff.</p>
	</div>
	<div style="position:absolute; bottom: 40px; left: 80px;">
		<h2>Preferences</h2>
		<button id="toggleDark">Toggle Theme</button><br>
		<button id="saveGame">Save</button>
	</div>
	<div id="notificationContainer" style="position: absolute; z-index: -1; display: flex; bottom: 80px; text-align: center; align-items: center; width: 99%; flex-direction: column-reverse;">
	</div>
<footer>
	Â© Ryan Appleyard MMXXV
</footer>


</body>

<! ========================================================================= >

<script>

// #region Data

const DATA = {
	tacks: 0,
	fingerAmount: 0,
	workerAmount: 0,
	playedTime: 0
}

// Light and Dark refer to the themes they are paired with.
const COLOURS = {
	green: {
		light: "#3C983E",
		dark: "#6FD08C"
	},
	red: "#FC5130",
	text: {
		light: "#111111",
		dark: "#FFFFFF"
	},
	ascii: {
		light: "#5c5b59",
		dark: "#f5f1ec"
	}
}
let AutoValue = {
	FINGER: 0.25,
	WORKER: 0.4
};

let AutoPrice = {
	FINGER: 20,
	WORKER: 100
}

const saveData = {
	version: "1.0.0",
	resources: {
		tacks: DATA.tacks,
		fingers: DATA.fingerAmount,
		workers: DATA.workerAmount,
		playedTime: DATA.playedTime
	},
	//add whatever else.
	lastSave: Date.now()
}

// #endregion

let TPS = 0;
const FPS = 1000 / 32;
const tpsLbl = document.getElementById("tpsLbl");

let upTime = 0;
let startTime = Date.now();

const upTimeLbl = document.getElementById("upTimeLbl");
const dateTimeLbl = document.getElementById("dateTimeLbl");
const playedTimeLbl = document.getElementById("playedTimeLbl");
const notifCont = document.getElementById("notificationContainer");

// #region Save Logic

function saveGame(autosave){
	localStorage.setItem("tacksSave", JSON.stringify(DATA));
	if(!autosave) printNotification("Saved Game", COLOURS.green);
}

function autosaveGame(){
	saveGame(true);
	printNotification("Autosaved", COLOURS.green, 2000);
}

function loadGame(){
	const saveData = localStorage.getItem("tacksSave");
	if(saveData){
		let parsed = JSON.parse(saveData);
		DATA.tacks = parsed.tacks || 0;
		DATA.fingerAmount = parsed.fingerAmount || 0;
		DATA.workerAmount = parsed.workerAmount || 0;
		DATA.playedTime = parsed.playedTime || 0;
	}else{
		return;
	}
}

// #endregion


loadGame();
init();
automation();

// #region Game Logic

document.getElementById("btn").addEventListener("click", context=>{
increment((DATA.fingerAmount * AutoValue.FINGER) + 1);
});

document.getElementById("fingerBtn").addEventListener("click", context=>{
if(Buy("finger", 1, AutoPrice.FINGER)) DATA.fingerAmount++;
});

document.getElementById("workerBtn").addEventListener("click", context=>{
	if(Buy("worker", 1, AutoPrice.WORKER)) {
		DATA.workerAmount++;
		createGuy();
	}
});

document.getElementById("toggleDark").addEventListener("click", function(){
	var element = document.body;
	element.classList.toggle("light");
});

document.getElementById("saveGame").addEventListener("click", function(){
	saveGame();
})

setInterval(automation, 1000);
setInterval(display, FPS);
setInterval(autosaveGame, 600000);

function init(){
	incrementSpecific(DATA.workerAmount, "worker");
	incrementSpecific(DATA.fingerAmount, "finger");

	// Calculate compounding price changes.
}

function increment(amount){
	DATA.tacks += amount;
}

function incrementSpecific(amount, name){
	var label = document.getElementById(name + "Lbl");
	currentNo = parseFloat(label.textContent) + amount;
	label.textContent = Math.floor(currentNo);
}

function decrement(amount){
	DATA.tacks -= amount;
}

function canAfford(price){
	return true ? price <= parseInt(DATA.tacks, 10) : false;
}

function Buy(type, amount, price){
	if(canAfford(price)){
		decrement(price);
		incrementSpecific(amount, type);
		printNotification("Bought: " + amount + "x " + type, COLOURS.text, 2000);
		return true;
	}
	else{
		printNotification("Can't afford another " + type, COLOURS.red, 2000);
		return false;
	}		
}

// Called once per second
function automation(){
	calculateTPS();
	tpsLbl.textContent = "Tacks p/s: " + TPS.toFixed(2);
	dateTimeLbl.textContent = new Date().toLocaleString();
	upTime++;
	var upTimeElapsed = convertTime(upTime);
	upTimeLbl.textContent = "Up Time: " + upTimeElapsed;
	DATA.playedTime++;
	var playedTimeElapsed = convertTime(DATA.playedTime)
	playedTimeLbl.textContent = "Played Time: " + playedTimeElapsed;
}

// Called 24 times per second
function display(){
	increment(TPS / FPS);
	lbl.textContent = numberWithCommas(Math.floor(DATA.tacks));
}

function calculateTPS(){
	TPS = AutoValue.WORKER * DATA.workerAmount;
}
// #endregion

// #region Utilities

// #endregion

// #region Print & Display

function convertTime(timeIn){
	const hours = Math.floor(timeIn / 3600);
	const minutes = Math.floor((timeIn % 36000) / 60);
	const seconds = timeIn % 60;

	return hours + "h " + minutes + "m " + seconds + "s";
}

function printNotification(message, color, duration = 3000){
	const note = document.createElement("div");
	note.className = "notification";
	note.textContent = message;
	note.style.color = getColor(color);

	notifCont.appendChild(note);

	setTimeout(() =>{
		note.classList.remove("show");
		note.classList.add("hide");
		setTimeout(() => note.remove(), 500);
	}, duration);
}

function getColor(type) {
    if (typeof type === "string") return type;
    return isLightMode() ? type.light : type.dark;
}

function isLightMode() {
    return document.body.classList.contains("light");
}

function numberWithCommas(x) {
    x = x.toString();
    var pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(x))
        x = x.replace(pattern, "$1,$2");
    return x;
}

function resizeCanvas(){
	workerCanvas.width = window.innerWidth - 80;

	guys.forEach(g =>{
		g.homeX = Math.random() * workerCanvas.width;
	})
}
window.addEventListener("resize", resizeCanvas);

// #endregion

// #region Perlin
const perm = new Uint8Array(512);
for (let i = 0; i < 256; i++) perm[i] = i;
for (let i = 255; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [perm[i], perm[j]] = [perm[j], perm[i]];
}
for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];

function fade(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return a + t * (b - a);
}

function grad(hash, x, y, z) {
  const h = hash & 15;
  const u = h < 8 ? x : y;
  const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
  return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

function perlin(x, y, z) {
  const X = Math.floor(x) & 255;
  const Y = Math.floor(y) & 255;
  const Z = Math.floor(z) & 255;

  x -= Math.floor(x);
  y -= Math.floor(y);
  z -= Math.floor(z);

  const u = fade(x);
  const v = fade(y);
  const w = fade(z);

  const A  = perm[X] + Y, AA = perm[A] + Z, AB = perm[A + 1] + Z;
  const B  = perm[X + 1] + Y, BA = perm[B] + Z, BB = perm[B + 1] + Z;

  return lerp(
    lerp(
      lerp(grad(perm[AA], x, y, z),
           grad(perm[BA], x - 1, y, z), u),
      lerp(grad(perm[AB], x, y - 1, z),
           grad(perm[BB], x - 1, y - 1, z), u), v),
    lerp(
      lerp(grad(perm[AA + 1], x, y, z - 1),
           grad(perm[BA + 1], x - 1, y, z - 1), u),
      lerp(grad(perm[AB + 1], x, y - 1, z - 1),
           grad(perm[BB + 1], x - 1, y - 1, z - 1), u), v),
    w
  );
}

// const chars = " '   .,-*=##$&@";
const chars = "    ..:oO0@ ";
const userScreen = document.getElementById("ascii");
let t = 0;
let paused = false;

function mapValueToChar(val) {
  const normalized = (val + 1) / 2;
  const index = Math.floor(normalized * (chars.length - 1));
  return chars[index];
}

function renderFrame() {
    if (!paused) {
        let output = "";
        const width = userScreen.clientWidth / 6;

		if(width == 0) console.log("ISSUE");
        const height = 18;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const value = perlin(x * 0.1, y * 0.1, t);
        output += mapValueToChar(value);
      }
      output += "\n";
    }

    userScreen.textContent = output;
    t += 0.01;
  }
}

// Don't want this for prod
// document.addEventListener("keydown", (e) => {
//   if (e.code === "Space") paused = !paused;
// });

setInterval(renderFrame, FPS);

// #endregion

// #region Guys
const workerCanvas = document.getElementById("workerCanvas");
const ctx = workerCanvas.getContext("2d");
workerCanvas.width = window.innerWidth - 80;
workerCanvas.height = 200;

const CHAR_GUY = [
  "  o  ",
  " /|\\ ",
  " / \\ "
];

const CHAR_FINGER = [
   "   ^",
   "r^^| ",
  "\\__|)"
];



const mouse = { x: 0, y: 0 };
const guys = [];
const WIGGLE_AMPLITUDE = 2; // max wiggle in pixels
const WIGGLE_SPEED = 0.01;  // speed of wiggle
const REPULSION_RADIUS = 450; // smaller radius so repulsion looks nicer
const REPULSION_FORCE = 2; // how strongly guys get pushed away

const BASE_FONT_SIZE = 12;
const MAX_FONT_SIZE = 16;
const SCALE_RADIUS = 100;

let guysCount = DATA.workerAmount;

// Initialize guys with fixed home positions and unique IDs
for (let i = 0; i < guysCount; i++) {
	guys.push({
		homeX: Math.random() * (workerCanvas.width - 80),
		homeY: Math.random() * (workerCanvas.height - 20),
		id: i
	});
}

	workerCanvas.addEventListener("mousemove", e => {
		const rect = workerCanvas.getBoundingClientRect(); // get canvas position & size
		mouse.x = e.clientX - rect.left; // mouse x relative to canvas
		mouse.y = e.clientY - rect.top;  // mouse y relative to canvas
	});

	// canvas.addEventListener("click", () => {
	//   guysCount++;
	//   guys.push({
	//     homeX: mouse.x,
	//     homeY: mouse.y,
	//     id: guysCount
	//   });
	//   console.log(`Added guy #${guysCount} at (${mouse.x}, ${mouse.y})`);
	// });

	function createGuy(x, y){
		guysCount++;
		guys.push({
			homeX: Math.random() * (workerCanvas.width - 80),
			homeY: Math.random() * (workerCanvas.height - 20),
			id: guysCount
		});
	}

	function drawGuy(x, y, scale) {
		const fontSize = BASE_FONT_SIZE * scale;
		const lineHeight = fontSize;

		ctx.font = fontSize + "px monospace";
		ctx.textBaseline = "top";
		ctx.fillStyle = getColor(COLOURS.ascii);
		for (let i = 0; i < CHAR_GUY.length; i++) {
			ctx.fillText(CHAR_GUY[i], x, y + i * lineHeight);
		}
	}

	let time = 0;

	function update() {
	ctx.clearRect(0, 0, workerCanvas.width, workerCanvas.height);
	time += WIGGLE_SPEED;


	guys.forEach(g => {
		// Calculate distance to mouse
		const dx = g.homeX - mouse.x;
		const dy = g.homeY - mouse.y;
		const dist = Math.sqrt(dx * dx + dy * dy);

		// Perlin noise wiggle
		const noiseX = perlin(time + g.id * 10, 0, 0) * 2 - 1; // [-1, 1]
		const noiseY = perlin(0, time + g.id * 10, 0) * 2 - 1;
		const wiggleX = noiseX * WIGGLE_AMPLITUDE;
		const wiggleY = noiseY * WIGGLE_AMPLITUDE;

		let offsetX = wiggleX;
		let offsetY = wiggleY;

		// If within repulsion radius, push away from mouse
		if (dist < REPULSION_RADIUS && dist > 0.01) {
		const nx = dx / dist;
		const ny = dy / dist;
		const repulseStrength = (REPULSION_RADIUS - dist) / REPULSION_RADIUS * REPULSION_FORCE;
		offsetX += nx * repulseStrength;
		offsetY += ny * repulseStrength;
		}

		let scale = 1;
		if(dist < SCALE_RADIUS){
			const t= 1 - dist / SCALE_RADIUS;
			scale = 1 + t * ((MAX_FONT_SIZE / BASE_FONT_SIZE) -1);
		}

		const drawX = g.homeX + offsetX;
		const drawY = g.homeY + offsetY;

		drawGuy(drawX, drawY, scale);
	});

	
	
	requestAnimationFrame(update);
}

// #endregion





update();

</script>
</html>
























