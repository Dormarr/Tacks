<!DOCTYPE html>
<html lang="en-UK">
<head>
	<meta charset="utf-8"/>
	<title id="title">Tacks</title>
	<meta name="viewport" content="width=device-width"/>
<style>
:root{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #E1D8C1;
	--feature: coral;
}
.light{
	--black: #171717;
	--white: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #5c5b59;
	--feature: coral;
}
.dark{
	--white: #171717;
	--black: #f5f1ec;
	--whiteAccent: #DDD;
	--ascii: #E1D8C1;
	--feature: coral;
}
body{
	width: 100vw;
	text-align: center;
	background-color: var(--white);
	color: var(--black);
	font-family:monospace;
	margin: 0px;
	min-height: 100vh;
	overflow-x: hidden;
	overflow-y: scroll;
}
.dark-mode{
	background-color: var(--black);
	color: var(--white);
}
p.tps{
	font-style: italic;
	font-size: 14px;
	margin: 0px;
}
h1 {
	text-align: center;
	color: var(--black);
}
h1.title{
	text-align: center;
	color:  vaR(--black);
	font-size: 48px;
	margin: 0px;
}
h2 {
	font-size: 24px;
	margin: 8px;
	color: var(--black);
}
button{
	font-size: 16px;
	padding: 8px;
	margin: 4px;
	color: var(--white);
	background-color: var(--black);
	transition-duration: 0.2s;
	font-family: monospace;
	font-weight: bold;
}
button:hover{
	background-color: var(--feature);

}
label{
	font-size: 32px;
	color: var(--black);
	padding: 12px;
	font-family: monospace;
}
label.small{
	font-size: 16px;
	padding: 2px;
}
footer {
	position: relative;
	height: 100px;
	width: 100%;
	text-align: center;
	align-content: center;
	z-index: 10;
}
div.widget{
	background-color: var(--white);
	border: solid 1px var(--black);
	min-width: 250px;
	width: fit-content;
	padding: 12px;
	margin: 12px;
	border-radius: 4px;
	text-align: center;
	position: relative;
	
	&.buy{
		top: -180px;
	}
}
#ascii{
	width: 100vw;
	overflow-x: hidden;
	position: relative;
	margin: 0px;
	color: var(--ascii);
}
.notification{
	color: var(--white);
	padding: 10px;
	font-family: monospace;
	transition-duration: 0.2s;
	z-index: 10;
	width: fit-content;
	pointer-events: none;
}
.notification.show{
	opacity: 0.9;
}
.notification.hide{
	opacity: 0;
}
.slice{
	width: 100%;
	height: 201px;
	display: flex;
	align-items: center;
	flex-direction: column;
}
canvas{
	height: 200px;
	width: 100vw;
}
div.line{
	width: 100%;
	height: 1px;
	background-color: var(--ascii);
}
.marquee-text {
  overflow: clip;
}

.marquee-text-track {
  display: flex;
  padding-left: 256px;
  gap: 256px;
  width: max-content;
  animation: marquee-move-text var(--speed, 17s) linear infinite var(
      --direction,
      forwards
    );
}

.marquee-text p {
  font-size: 16px;
  margin: 0px;
  padding-left: 256px;
}

@keyframes marquee-move-text {
  to {
    transform: translateX(-50%);
  }
}



</style>
</head>
<! ========================================================================= >
<body>
	<div style="height: 290px">
		<pre id="ascii" style="z-index: -1;"></pre>
		<div class="line"></div>
		<div class="marquee-text">
		<div class="marquee-text-track">
			<p>This is a work in progress, be gentle.</p>
			<p>This is a work in progress, be gentle.</p>
			<p>This is a work in progress, be gentle.</p>
			<p>This is a work in progress, be gentle.</p>
			<p aria-hidden="true">This is a work in progress, be gentle.</p>
			<p aria-hidden="true">This is a work in progress, be gentle.</p>
			<p aria-hidden="true">This is a work in progress, be gentle.</p>
			<p aria-hidden="true">This is a work in progress, be gentle.</p>

		</div>
		</div>
		<div style="display: flex; flex-direction: column; align-items: center; width: 100%">
			<div class="widget buy">
				<h1 class="title">Tacks</h1>
				<p style="color: var(--black); margin-top: 0px;">A Lesser Paperclips</p>
				<br>
				<p class="tps" style="text-align:center" id="tpsLbl">Click to increment.</p>
				<label id="tacksLbl">0</label>
				<br>
				<button id="btn" style="margin-top: 24px; width: 128px">Boop</button>
			</div>
		</div>
	</div>
	
	<div class="line"></div>
	<div id="tackSlice" class="slice">
		<canvas id="tackCanvas"></canvas>
	</div>
	<div class="line"></div>
	
	<h2> Upgrades & Automation</h2>
	
	<div style="display: flex; flex-direction: column; width: 100%">
		<div style="width: 100vw; display: flex; max-width: 100vw; flex-direction: column">
			<div class="line"></div>
			<div id="pointerSlice" class="slice">
				<canvas id="pointerCanvas"></canvas>
				<div class="widget buy">
					<button id="pointerBtn">Buy Extra Finger</button>
					<div>
						<label class="small">+0.25 per click</label> <br>
						<label class="small">Cost: 20</label>
						<br>
						<label class="small">Owned:<label class="small" id="pointerAmountLbl">0</label></label>
					</div>
				</div>
			</div>
			<div class="line"></div>
			<div id="workerSlice" class="slice">
				<canvas id="workerCanvas"></canvas>
				<div class="widget buy">
					<button id="workerBtn">Buy Worker</button>
					<div>
						<label class="small">+0.4 per second</label><br>
						<label class="small">Cost: 100</label>
						<br>
						<label class="small">Owned:<label class="small" id="workerAmountLbl">0</label></label>
					</div>
				</div>
			</div>
			<div class="line"></div>
			<div id="dropperSlice" class="slice">
				<canvas id="dropperCanvas"></canvas>
				<div class="widget buy">
					<button id="workerBtn">Buy Dropshipper</button>
					<div>
						<label class="small">+100 per minute (randomly)</label><br>
						<label class="small">Cost: 1000</label>
						<br>
						<label class="small">Owned:<label class="small" id="dropperAmountLbl">0</label></label>
					</div>
				</div>
			</div>
			<div class="line"></div>
			<!-- TEMPLATE ==================================================================== -->
			<div id="templateSlice" class="slice">
				<canvas id="templateCanvas"></canvas>
				<div class="widget buy">
					<button id="templateBtn">Buy Template</button>
					<div>
						<label class="small">+X per Y</label><br>
						<label class="small">Cost: Z</label>
						<br>
						<label class="small">Owned:<label class="small" id="templateAmountLbl">0</label></label>
					</div>
				</div>
			</div>
			<div class="line"></div>
			<!-- TEMPLATE ==================================================================== -->
		</div>
	</div>
	<div style="align-content: left; z-index: 1; position: fixed; bottom: 16px; left: 16px;">
		<h2>Preferences</h2>
		<button id="toggleDark">Toggle Theme</button><br>
		<button id="saveGame">Save</button>
		<button id="newGame">New</button>
		<button id="cheat">Cheat</button>
	</div>
	<div style="text-align: right; position: fixed; right: 16px; bottom: 16px;">
		<label class="small"; id="dateTimeLbl">DateTime</label>
		<br>
		<label class="small"; id="upTimeLbl">UpTime</label>
		<br>
		<label class="small"; id="playedTimeLbl">PlayedTime</label>
		<br>
		<p>Add more debug stuff.</p>
	</div>
	<div id="notificationContainer" style="pointer-events: none; position: fixed; display: flex; bottom: 32px; text-align: center; align-items: center; width: 100%; flex-direction: column-reverse;">
	</div>
<footer style="pointer-events: none; padding-bottom: 16px;">
	<label class="small" id="versionLbl"></label>
	<br>
	<label class="small">© Ryan Appleyard MMXXV</label>	
</footer>


</body>
<script>

/*=========================================================================

- Fix timers
- Create a seed function
- Reorganise
- Sort out string storage 	i.e: preferences.theme?'1':'0'; etc.
- Tool tips and dynamic HTML

-- Tackonomics --
A rework of the Tack in/out system. Already well overdue I reckon.
Needs to work nicely with centralised data fields.
Ensure it scales so laggable scale of ownership isn't attainable.

-- Politacks --
Worm your way into politics by buying off government officials, lobbying for bills, and funding wars abroad.
Basically becomes a whole other game akin to like, risk.

Finger 		Increase per click
Scavenger	Increase per second
Dropshipper	Increase per minute (randomly)
3D Printer	Increase per second
Warehouse Upgrade	Intro to commercial industry
Workers		Increase per second (during day only: pending labour law change)
R&D Upgrade		Branches off to researching new methods of production - A research/tech tree?

Beyond this it could go anywhere.

=========================================================================*/

// #region Data

/*=========================================================================

VERSIONING
Major 0 for pre-release, 1 for release
Minor: Increment for playable versions.
Build: Defined by feature additions. Add 'a' or 'b' for alphas and beta respectively.
Revision: Don't really need. But would increment per commit.
Date: Formatted as 'YY.MM'.

=========================================================================*/

const MAJOR = "0";
const MINOR = "2";
const BUILD = "4a";
const REVISION = ""; //add decimal if using.

function getDateArray(){
	//return as YY.MM
	const cd = new Date();
	var y = cd.getFullYear();
	var m = cd.getMonth() + 1; //zero indexed
	if(m <= 9) m = "0" + m; //add zero to front of month (9 -> 09)
	var d = cd.getDate();
	return (`${d}/${m}/${y}`);
}

function getVersionDate(){
	var date = getDateArray();

	const re = /^(3[01]|[12][0-9]|0?[1-9])(\/|-)(1[0-2]|0[1-9])\2([0-9]{2})?[0-9]{2}$/;
	var r = date.toString(re);
	return (`${r[8]}${r[9]}.${r[3]}${r[4]}`);
}

function getYearInNumerals(){
	// I want MMXXV for 2025
	// It's another regex challenge
}

const VERSION_DATE = getVersionDate();

function getVersion(){
	var V = `v${MAJOR}.${MINOR}.${BUILD}${REVISION}-${VERSION_DATE}`;
	if(!V) return "Error fetching Version";
	return V;
}

const VERSION = getVersion();

const THEME = {
	DARK: 'dark',
	LIGHT: 'light'
}

const DATA = {
	version: VERSION,
	seed: 0,
	tacksEarned: 0,
	tacks: 0,
	clicks: 0,
	handmadeTacks: 0,
	pointerAmount: 0,
	workerAmount: 0,
	playedTime: 0,
	theme: THEME.DARK
}

// Tacks earned, clicks, handmadeTacks (by click), preferredTheme


// Light and Dark refer to the themes they are paired with.
const COLOURS = {
	green: {
		light: "#3C983E",
		dark: "#6FD08C"
	},
	red: "#FC5130",
	text: {
		light: "#121212",
		dark: "#F7F7F7"
	},
	ascii: {
		light: "#5c5b59",
		dark: "#B1A688"
	}
}

let AutoValue = {
	POINTER: 0.25,
	WORKER: 0.4
}

let AutoPrice = {
	POINTER: 20,
	WORKER: 100
}


// #endregion

let TPS = 0;
const FPS = 1000 / 32;
const tpsLbl = document.getElementById("tpsLbl");

let upTime = 0;
let startTime = Date.now();

const notificationContainer = document.getElementById("notificationContainer");
const title = document.getElementById("title");

const updateLabel = {
	version: (val) => { document.getElementById("versionLbl").textContent = val; },
	tacks: (val) => { document.getElementById("tacksLbl").textContent = val; },
	pointerAmount: (val) => { document.getElementById("pointerAmountLbl").textContent = val; },
	workerAmount: (val) => { document.getElementById("workerAmountLbl").textContent = val; },
	// Add more as needed...
};

// #region Save Logic

async function newGame() {
	localStorage.removeItem("tacksSave");
	await loadGame(true);
	refresh();

	printNotification("New Game Started", COLOURS.green);
}

const FIXED_KEY = "tackstack-key123"; // Shared secret
const FIXED_SALT = new TextEncoder().encode("tackstack-salt");

// Derive a persistent key using PBKDF2
async function getKey() {
	if (!window.encryptionKey) {
		const keyMaterial = await crypto.subtle.importKey(
			"raw",
			new TextEncoder().encode(FIXED_KEY),
			{ name: "PBKDF2" },
			false,
			["deriveKey"]
		);

		window.encryptionKey = await crypto.subtle.deriveKey(
			{
				name: "PBKDF2",
				salt: FIXED_SALT,
				iterations: 100000,
				hash: "SHA-256"
			},
			keyMaterial,
			{ name: "AES-GCM", length: 256 },
			false,
			["encrypt", "decrypt"]
		);
	}
	return window.encryptionKey;
}

async function saveGame(autosave) {
	const key = await getKey();
	const iv = crypto.getRandomValues(new Uint8Array(12));
	const encoded = new TextEncoder().encode(JSON.stringify(DATA));
	const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

	const encryptedData = {
		iv: Array.from(iv),
		cipherText: Array.from(new Uint8Array(encrypted))
	};

	localStorage.setItem("tacksSave", JSON.stringify(encryptedData));

	if (!autosave) printNotification("Saved Game", COLOURS.green);
}

function autosaveGame() {
	saveGame(true);
	printNotification("Autosaved", COLOURS.green, 2000);
}

async function loadGame(newGame) {

	if(newGame){
		DATA.tacks =  0;
		DATA.pointerAmount = 0;
		DATA.workerAmount = 0;
		DATA.playedTime = 0;
		DATA.version = getVersion();
		DATA.theme = THEME.DARK; // Is there a way to get this to be system default?
		refresh();
		printNotification("New Game!", COLOURS.green);
		return;
	}

	const raw = localStorage.getItem("tacksSave");
	if (!raw) return;

	try {
		const encryptedData = JSON.parse(raw);
		const key = await getKey();
		const iv = new Uint8Array(encryptedData.iv);
		const cipherText = new Uint8Array(encryptedData.cipherText);

		const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, cipherText);
		const json = new TextDecoder().decode(decrypted);
		const parsed = JSON.parse(json);

		DATA.tacks = parsed.tacks || 0;
		DATA.pointerAmount = parsed.pointerAmount || 0;
		DATA.workerAmount = parsed.workerAmount || 0;
		DATA.playedTime = parsed.playedTime || 0;
		DATA.version = parsed.version || getVersion();
		DATA.theme = parsed.theme || THEME.DARK;
		refresh();
		printNotification("Game Loaded", COLOURS.green);
	} catch (err) {
		console.error("Decryption failed:", err);
	}
}


// #endregion


loadGame();

updateLabel["version"](DATA.version);

// #region Buttons

document.getElementById("btn").addEventListener("click", context=>{
	increment((DATA.pointerAmount * AutoValue.POINTER) + 1);
});

document.getElementById("pointerBtn").addEventListener("click", context=>{
	if(canAfford(AutoPrice.POINTER)){
		buy("pointer", 1, AutoPrice.POINTER);
		createPointer();
	}
});

document.getElementById("workerBtn").addEventListener("click", context=>{
	if(canAfford(AutoPrice.WORKER)){
		buy("worker", 1, AutoPrice.WORKER);
		createWorker();
	}
});

document.getElementById("toggleDark").addEventListener("click", function(){
	toggleTheme();
});

document.getElementById("saveGame").addEventListener("click", function(){
	saveGame();
})

document.getElementById("newGame").addEventListener("click", function(){
	newGame();
})

document.getElementById("cheat").addEventListener("click", function(){
	incrementDataField("tacks", 999999);
	buy("worker", 10, AutoPrice.WORKER);
	createWorker(10);
	buy("pointer", 10, AutoPrice.POINTER);
	createPointer(10);
});

// #endregion

// #region Game Logic


setInterval(automation, 1000);
setInterval(display, FPS);
setInterval(autosaveGame, 600000);
setInterval(createTack, 1000 / 4);

function refresh(){
	forceUpdateTheme();
	setDataField("tacks", DATA.tacks);
	setDataField("workerAmount", DATA.workerAmount);
	setDataField("pointerAmount", DATA.pointerAmount);
	repopulate();
	// Calculate compounding price changes.
	
}

function repopulate(){
	populateGuys();
	populatePointers();
}

function increment(amount){
	DATA.tacks += amount;
}

function incrementSpecific(name, amount) {
	const label = document.getElementById(name + "Lbl");

	if (!label) {
		console.warn(`Label element not found: ${name}Lbl`);
		return;
	}

	let currentVal = parseFloat(label.textContent);
	if (isNaN(currentVal)) currentVal = 0;

	const newVal = currentVal + amount;
	label.textContent = Math.floor(newVal);
}


function incrementDataField(fieldName, amount = 1) {
	if (Object.prototype.hasOwnProperty.call(DATA, fieldName) && typeof DATA[fieldName] === "number") {
		DATA[fieldName] += amount;

		// Check for a label updater function specific to this field
		if (typeof updateLabel[fieldName] === "function") {
			updateLabel[fieldName](DATA[fieldName]);
		}

		return DATA[fieldName];
	} else {
		console.warn(`Invalid field name or non-numeric field: "${fieldName}"`);
		return null;
	}
}

function setDataField(fieldName, amount = 1) {
	if (Object.prototype.hasOwnProperty.call(DATA, fieldName) && typeof DATA[fieldName] === "number") {
		DATA[fieldName] = amount;

		// Check for a label updater function specific to this field
		if (typeof updateLabel[fieldName] === "function") {
			updateLabel[fieldName](DATA[fieldName]);
		}

		return DATA[fieldName];
	} else {
		console.warn(`Invalid field name or non-numeric field: "${fieldName}"`);
		return null;
	}
}


function decrement(amount){
	DATA.tacks -= amount;
}

function canAfford(price){
	return true ? price <= parseInt(DATA.tacks, 10) : false;
}

function buy(type, amount, price){
	if(canAfford(price)){
		decrement(price);
		incrementDataField(type + "Amount", amount);
		printNotification("Bought: " + amount + "x " + type, COLOURS.text, 2000);
		return true;
	}
	else{
		printNotification("Can't afford another " + type, COLOURS.red, 2000);
		return false;
	}
}

function calculateTPS(){
	TPS = AutoValue.WORKER * DATA.workerAmount;
	// Add automation elements to this ------------------------------------------------------------------- !!
}
// #endregion

// #region Utility

function getExclusion(canvas){
	return {
    x: canvas.width / 2 - 175,
    y: canvas.height / 2 - 90,
    width: 300,
    height: 150
	};
}

function createSprite(count, sprite, canvas, collection, amount){
	count += amount
	populateSprite(count, sprite, canvas, collection);
}

function populateSprite(count, sprite, canvas, collection){
	const exclusion = getExclusion(canvas);

	for (let i = 0; i < count; i++) {
		const {x: X, y:Y} = getValidPosition(canvas, exclusion)
		collection.push({
			homeX: X,
			homeY: Y,
			id: i,
			sprite: sprite[Math.floor(Math.random() * sprite.length)]
		});
	}
}

function getValidPosition(canvas, exclusion){
	let x, y;
    do {
       	x = Math.random() * (canvas.width - 80);
       	y = Math.random() * (canvas.height - 20);
    } while (
        x > exclusion.x &&
        x < exclusion.x + exclusion.width &&
        y > exclusion.y &&
        y < exclusion.y + exclusion.height
    );
    return { x, y };
}

function getValidPositionX(canvas, exclusion){
	let both = getValidPosition(canvas, exclusion);
	return both[0];
}

function getValidPositionY(canvas, exclusion){
	let both = getValidPosition(canvas, exclusion);
	return both[1];
}

function wiggle(g, mouse, yMove){
	
	const dx = g.homeX - mouse.x;
	const dy = g.homeY - mouse.y;
	const dist = Math.sqrt(dx * dx + dy * dy);

	// Perlin noise wiggle
	const noiseX = perlin(time + g.id * 10, 0, 0) * 2 - 1; // [-1, 1]
	const noiseY = perlin(0, time + g.id * 10, 0) * 2 - 1;
	const wiggleX = noiseX * WIGGLE_AMPLITUDE;
	const wiggleY = noiseY * WIGGLE_AMPLITUDE;

	let sinY = sinWave(wiggleY * yMove, 10);

	let offsetX = wiggleX;
	let offsetY = wiggleY + sinY;

	// If within repulsion radius, push away from mouse
	if (dist < REPULSION_RADIUS && dist > 0.01) {
	const nx = dx / dist;
	const ny = dy / dist;
	const repulseStrength = (REPULSION_RADIUS - dist) / REPULSION_RADIUS * REPULSION_FORCE;
	offsetX += nx * repulseStrength;
	offsetY += ny * repulseStrength;
	}

	let scale = 1;
	if(dist < SCALE_RADIUS){
		const t= 1 - dist / SCALE_RADIUS;
		scale = 1 + t * ((W_MAX_FONT_SIZE / W_BASE_FONT_SIZE) -1);
	}

	const drawX = g.homeX + offsetX;
	const drawY = g.homeY + offsetY;
	

	const drawVector = [drawX, drawY, scale, sinY];

	return drawVector;
}

function sinWave(radian, radius){
	return Math.sin(radian) * radius;
}

// #endregion

// #region Print & Display

// Called once per second
function automation(){
	calculateTPS();
	tpsLbl.textContent = TPS.toFixed(2) + " tps";
	dateTimeLbl.textContent = new Date().toLocaleString();
	upTime++;
	var upTimeElapsed = convertTime(upTime);
	upTimeLbl.textContent = "Up Time: " + upTimeElapsed;
	DATA.playedTime++;
	var playedTimeElapsed = convertTime(DATA.playedTime)
	playedTimeLbl.textContent = "Played Time: " + playedTimeElapsed;

	title.textContent = DATA.tacks.toFixed(0) + " Tacks!";
}

// Called 24 times per second
function display(){
	increment(TPS / FPS);
	tacksLbl.textContent = numberWithCommas(Math.floor(DATA.tacks));
}

function toggleTheme(){
	document.body.classList.toggle("light");
	updateTheme();
}

function updateTheme(){
	if(getCurrentTheme() === "light"){
		DATA.theme = THEME.LIGHT;
		console.log("Updated DATA.theme to light.");
	}
	else{
		DATA.theme = THEME.DARK;
		console.log("Updated DATA.theme to dark.");
	}
}

function forceUpdateTheme(){
	// Test to see if theme matches data, if not then toggle.

	if(DATA.theme != getCurrentTheme()){
		toggleTheme();
	}
}

function getCurrentTheme(){
	return isLightMode() ? THEME.LIGHT: THEME.DARK;
}

function convertTime(timeIn){

	// This needs fixing, it's going up to like 100 minutes.

	const hours = Math.floor(timeIn / 3600);
	const minutes = Math.floor((timeIn % 36000) / 60);
	const seconds = timeIn % 60;

	return (`${hours}h ${minutes}m ${seconds}s`);
}

function printNotification(message, color, duration = 3000){
	const note = document.createElement("div");
	note.className = "notification";
	note.textContent = message;
	note.style.color = getColor(color);

	notificationContainer.appendChild(note);

	setTimeout(() =>{
		note.classList.remove("show");
		note.classList.add("hide");
		setTimeout(() => note.remove(), 500);
	}, duration);
}

function getColor(type) {
    if (typeof type === "string") return type;
    return isLightMode() ? type.light : type.dark;
}

function isLightMode() {
    return document.body.classList.contains("light");
}

function numberWithCommas(x) {
    x = x.toString();
    var pattern = /(-?\d+)(\d{3})/;
    while (pattern.test(x))
        x = x.replace(pattern, "$1,$2");
    return x;
}

window.addEventListener("resize", resizeWindow);

function resizeWindow(){
	resizeCanvas(workerCanvas, workers);
	resizeCanvas(pointerCanvas, pointers);
}

function resizeCanvas(canvas, collection){
	canvas.height = window.innerHeight;
	canvas.width = window.innerWidth - 80;
	const exclusion = getExclusion(canvas);

	collection.forEach(g =>{
		g.homeX = getValidPositionX(canvas, exclusion);
	})
}

// #endregion

// #region Perlin
const perm = new Uint8Array(512);
for (let i = 0; i < 256; i++) perm[i] = i;
for (let i = 255; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [perm[i], perm[j]] = [perm[j], perm[i]];
}
for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];

function fade(t) {
  return t * t * t * (t * (t * 6 - 15) + 10);
}

function lerp(a, b, t) {
  return a + t * (b - a);
}

function grad(hash, x, y, z) {
  const h = hash & 15;
  const u = h < 8 ? x : y;
  const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
  return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
}

function perlin(x, y, z) {
  const X = Math.floor(x) & 255;
  const Y = Math.floor(y) & 255;
  const Z = Math.floor(z) & 255;

  x -= Math.floor(x);
  y -= Math.floor(y);
  z -= Math.floor(z);

  const u = fade(x);
  const v = fade(y);
  const w = fade(z);

  const A  = perm[X] + Y, AA = perm[A] + Z, AB = perm[A + 1] + Z;
  const B  = perm[X + 1] + Y, BA = perm[B] + Z, BB = perm[B + 1] + Z;

  return lerp(
    lerp(
      lerp(grad(perm[AA], x, y, z),
           grad(perm[BA], x - 1, y, z), u),
      lerp(grad(perm[AB], x, y - 1, z),
           grad(perm[BB], x - 1, y - 1, z), u), v),
    lerp(
      lerp(grad(perm[AA + 1], x, y, z - 1),
           grad(perm[BA + 1], x - 1, y, z - 1), u),
      lerp(grad(perm[AB + 1], x, y - 1, z - 1),
           grad(perm[BB + 1], x - 1, y - 1, z - 1), u), v),
    w
  );
}

// const chars = " '   .,-*=##$&@";
const chars = "    ..:oO0@ ";
const userScreen = document.getElementById("ascii");
let t = 0;
let paused = false;

function mapValueToChar(val) {
  const normalized = (val + 1) / 2;
  const index = Math.floor(normalized * (chars.length - 1));
  return chars[index];
}

function renderFrame() {
    if (!paused) {
        let output = "";
        const width = userScreen.clientWidth / 6;

		if(width == 0) console.log("ISSUE");
        const height = 18;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const value = perlin(x * 0.1, y * 0.1, t);
        output += mapValueToChar(value);
      }
      output += "\n";
    }

    userScreen.textContent = output;
    t += 0.01;
  }
}

// Don't want this for prod
// document.addEventListener("keydown", (e) => {
//   if (e.code === "Space") paused = !paused;
// });

setInterval(renderFrame, FPS);

// #endregion

// #region Ascii Shared

const WIGGLE_AMPLITUDE = 2; // max wiggle in pixels
const WIGGLE_SPEED = 0.01;  // speed of wiggle
const REPULSION_RADIUS = 450; // smaller radius so repulsion looks nicer
const REPULSION_FORCE = 2; // how strongly guys get pushed away

const P_BASE_FONT_SIZE = 8;
const W_BASE_FONT_SIZE = 12;
const W_MAX_FONT_SIZE = 16;
const P_MAX_FONT_SIZE = 13;
const SCALE_RADIUS = 100;
const ROT_RADIUS = 100;

// #endregion

// #region Guys

function populateGuys(){
	populateSprite(DATA.workerAmount, CHAR_GUY, workerCanvas, workers);
}

function createWorker(amount = 1){
	createSprite(workerCount, CHAR_GUY, workerCanvas, workers, amount);
}

const workerCanvas = document.getElementById("workerCanvas");
const workerCtx = workerCanvas.getContext("2d");
workerCanvas.width = window.innerWidth;
workerCanvas.height = 200;

const CHAR_GUY = [
[
	"  o  ",
	" /#\\ ",
	" / \\ "
],
[
	"  o  ",
	" <#v ",
	" / \\ "
],
[
	"  o  ",
	" <T> ",
	" / \\ "
],
[
	"  o  ",
	" /#> ",
	" / \\ "
],
[
	"  o  ",
	" /X\\ ",
	" / \\ "
],
[
	"  o  ",
	" (Y) ",
	" / \\ "
]];

let workerCount = 0;
const workerMouse = { x: 0, y: 0 };
const workers = [];

workerCanvas.addEventListener("mousemove", e => {
	const rect = workerCanvas.getBoundingClientRect(); // get canvas position & size
	workerMouse.x = e.clientX - rect.left; // mouse x relative to canvas
	workerMouse.y = e.clientY - rect.top;  // mouse y relative to canvas
});

function drawGuy(guySprite, x, y, scale) {
	const fontSize = W_BASE_FONT_SIZE * scale;
	const lineHeight = fontSize;

	workerCtx.font = fontSize + "px monospace";
	workerCtx.textBaseline = "top";
	workerCtx.fillStyle = getColor(COLOURS.ascii);
	for (let i = 0; i < guySprite.length; i++) {
		workerCtx.fillText(guySprite[i], x, y + i * lineHeight);
	}
}

let time = 0;

function updateWorker() {
	workerCtx.clearRect(0, 0, workerCanvas.width, workerCanvas.height);
	time += WIGGLE_SPEED;

	workers.forEach(g => {
		const v = wiggle(g, workerMouse, 0);
		drawGuy(g.sprite, v[0], v[1], v[2]);
	});

	requestAnimationFrame(updateWorker);
}

// #endregion

// #region Pointers

function populatePointers(){
	populateSprite(DATA.pointerAmount, CHAR_POINTER, pointerCanvas, pointers);
}

function createPointer(amount = 1){
	createSprite(pointerCount, CHAR_POINTER, pointerCanvas, pointers, amount);
}

const pointerCanvas = document.getElementById("pointerCanvas");
const ctx2 = pointerCanvas.getContext("2d");
pointerCanvas.width = window.innerWidth;
pointerCanvas.height = 200;

const CHAR_POINTER = [[
	"   |  ",
	"r^^|  ",
	"\\__|) "
],
[
	"  |   ",
	"r^'^  ",
	"\\__|) "
]];

let pointerCount = 0;
const pointerMouse = { x: 0, y: 0 }
const pointers = [];

pointerCanvas.addEventListener("mousemove", e => {
    const rect = pointerCanvas.getBoundingClientRect(); // get canvas position & size
    pointerMouse.x = e.clientX - rect.left; // mouse x relative to canvas
    pointerMouse.y = e.clientY - rect.top;  // mouse y relative to canvas
});

function drawPointer(pointerSprite, x, y, scale) {
    const pointerFontSize = P_BASE_FONT_SIZE * scale;
    const lineHeight = pointerFontSize;

    ctx2.font = pointerFontSize + "px monospace";
    ctx2.textBaseline = "top";
    ctx2.fillStyle = getColor(COLOURS.ascii);

    for (let i = 0; i < pointerSprite.length; i++) {
        ctx2.fillText(pointerSprite[i], x, y + i * lineHeight);
    }
}



function updatePointer() {
    ctx2.clearRect(0, 0, pointerCanvas.width, pointerCanvas.height);
    time += WIGGLE_SPEED;

    pointers.forEach(p => {
	const v = wiggle(p, pointerMouse, 1.2);
        drawPointer(p.sprite, v[0], v[1], v[2]);
    });
    
    requestAnimationFrame(updatePointer);
}

updatePointer();
updateWorker();

// #endregion

// === CONFIG ===
// const TPS = 16;
const T_BASE_FONT_SIZE = 18;
const tackCount = 20;
const yVelocity = 1;

// === CANVAS SETUP ===
const tackCanvas = document.getElementById("tackCanvas");
const ctx3 = tackCanvas.getContext("2d");
tackCanvas.width = window.innerWidth;
tackCanvas.height = 200;

// === SPRITES & DATA ===
const CHAR_TACK = [
[ "Π",
  "T" ]];
let tacks = [];
const tackMouse = { x: 0, y: 0 };

// === EVENTS ===
tackCanvas.addEventListener("mousemove", e => {
	const rect = tackCanvas.getBoundingClientRect();
	tackMouse.x = e.clientX - rect.left;
	tackMouse.y = e.clientY - rect.top;
});

tackCanvas.addEventListener("click", e => {
	console.log("Click created Tack");
	drawTack(CHAR_TACK, e.x, e.y, 1);
})

// === DRAWING ===
function drawTack(tackSprite, x, y, scale) {
	const tackFontSize = T_BASE_FONT_SIZE * scale;
	const lineHeight = tackFontSize / 2;

	ctx3.font = `${tackFontSize}px monospace`;
	ctx3.textBaseline = "top";
	ctx3.fillStyle = getColor(COLOURS.ascii);

	for (let i = 0; i < tackSprite.length; i++) {
		ctx3.fillText(tackSprite[i], x, y + i * lineHeight);
	}
}

// === CREATION ===
function createTack(amount = 1) {
	console.log("Creating Tack");
	for (let i = 0; i < amount; i++) {
		const sprite = CHAR_TACK[Math.floor(Math.random() * CHAR_TACK.length)];
		tacks.push({
			homeX: Math.random() * (tackCanvas.width - 20),
			homeY: -30, // start above canvas
			sprite: sprite,
			scale: 1,
		});
	}
}

// === UPDATE LOOP ===
function updateTack(timestamp) {
	ctx3.clearRect(0, 0, tackCanvas.width, tackCanvas.height);

	// Update and draw
	tacks.forEach(p => {
		p.homeY += yVelocity;
	});
	tacks = tacks.filter(p => p.homeY < tackCanvas.height + 50);
	
	tacks.forEach(p => {
		const v = wiggle(p, tackMouse, 0);
		drawTack(p.sprite, v[0], v[1], v[2]);
	});

	requestAnimationFrame(updateTack);
}

updateTack();

// #region Naming & Formatting

/* ================================================

Factory Name, worker names, maybe number suffix handling.

=================================================*/


function generateFactoryName(){
	// randomly choose 2 (or 3?) words from lists that create a dumb name.
	return "Placeholder Inc";
}

function generateWorkerNames(){
	"Winston";
}


// #endregion

</script>
</html>